nodo_t* emprestadoDireitaFolha(nodo_t** pai, nodo_t** atual, nodo_t** irmao, int indicePai){
	int i;
	(*atual)->keys[(*atual)->quantidadeKeys] = (*irmao)->keys[0];
	(*atual)->offsets[(*atual)->quantidadeKeys] = (*irmao)->offsets[0];
	(*atual)->quantidadeKeys++;
	//AGRUPO OS ELEMENTOS DO IRMAO NO INICIO NOVAMENTE
	for(i = 1; i < (*irmao)->quantidadeKeys; i++){
		(*irmao)->keys[i-1] = (*irmao)->keys[i];
		(*irmao)->offsets[i-1] = (*irmao)->offsets[i];
	}
	(*irmao)->keys[i-1] = NULL;
	mataOffsets((*irmao)->offsets[i-1]);
	(*irmao)->quantidadeKeys--;
	(*pai)->keys[indicePai-1] = (*irmao)->keys[0];
	return *pai;
}

nodo_t* emprestadoEsquerdaFolha(nodo_t** pai, nodo_t** atual, nodo_t** irmao,int indicePai){
	int i;
	for (i = (*atual)->quantidadeKeys; i >= 0; i--) {
		(*atual)->keys[i] = (*atual)->keys[i-1];
		(*atual)->offsets[i] = (*atual)->offsets[i-1];
	}
	(*atual)->keys[(*atual)->quantidadeKeys-1] = (*irmao)->keys[(*irmao)->quantidadeKeys-1];
	(*atual)->offsets[(*atual)->quantidadeKeys-1] = (*irmao)->offsets[(*irmao)->quantidadeKeys-1];
	(*atual)->quantidadeKeys++;
	//AJUSTA O IRMAO
	(*irmao)->keys[(*irmao)->quantidadeKeys] = NULL;
	mataOffsets((*irmao)->offsets[(*irmao)->quantidadeKeys]);
	(*irmao)->quantidadeKeys--;
	(*pai)->keys[indicePai-2] = (*atual)->keys[0];
	return *pai;
}

nodo_t* verificaRaiz(nodo_t *atual){
	if(atual->quantidadeFilhos != 1 && atual->quantidadeKeys){//VERIFICA SE RESTA ELEMENTOS NO NÓ E SE TEM QUANTIDADE DE FILHOS DIFERENTE DE 1
		return atual;
	}
	if(atual->quantidadeFilhos == 1){//RESTOU APENAS UM FILHO, MATA O NODO E RETORNA ESSE FILHO
		atual->keys[0] = NULL;
		atual->filhos[0]->pai = NULL;
		return atual->filhos[0];
	}
	if(!atual->quantidadeKeys)
		return NULL;
}

nodo_t* verificaFolha(nodo_t *atual, int indicePai, int ordem){
	nodo_t *pai = atual->pai,*irmao;
	int i, qtdMinima = (ordem-1)/2;
	
	if(atual->pai->quantidadeFilhos > indicePai){//EXISTE UM IRMAO A DIREITA? POSSO PEGAR EMPRESTA DESSE IRMAO?
	  irmao = atual->pai->filhos[indicePai];
	  if(irmao->quantidadeKeys > qtdMinima){
		return emprestadoDireitaFolha(&pai,&atual,&irmao,indicePai);
	  }
	}
	if(indicePai-1){//EXISTE IRMAO A ESQUERDA? POSSO PEGAR EMPRESTA DESSE IRMAO?
	  	irmao = atual->pai->filhos[indicePai-2];
	  if(irmao->quantidadeKeys > qtdMinima){
		return emprestadoEsquerdaFolha(&pai,&atual,&irmao,indicePai);
	  }
	}
	
	if(atual->pai->quantidadeFilhos > indicePai){//EXISTE UM IRMAO A DIREITA? MERGE COM O IRMAO A DIREITA
		irmao = atual->pai->filhos[indicePai];
		for(i = 0; i < irmao->quantidadeKeys; i++){
			atual->keys[atual->quantidadeKeys] = irmao->keys[i];
			atual->offsets[atual->quantidadeKeys] = irmao->offsets[i];
			atual->quantidadeKeys++;
		}
		atual->prox = irmao->prox;
		atual->pai->filhos[indicePai] = atual;
		atual->pai->keys[indicePai-1] = atual->pai->keys[indicePai];
		mataArvore(irmao);
		return removeElemento(atual->pai, indicePai, ordem);
	}else{//MERGE COM O IRMAO A ESQUERDA
		irmao = atual->pai->filhos[indicePai-2];
		for(i = 0; i < atual->quantidadeKeys; i++){
			irmao->keys[irmao->quantidadeKeys] = atual->keys[i];
			irmao->offsets[irmao->quantidadeKeys] = atual->offsets[i];
			irmao->quantidadeKeys++;
		}
		atual->pai->keys[indicePai-2] = atual->pai->keys[indicePai-1];
		irmao->prox = atual->prox;
		mataArvore(atual);
		return removeElemento(irmao->pai, indicePai-1, ordem);
	}
}

nodo_t* emprestadoDireitaInterna(nodo_t** pai, nodo_t** atual, nodo_t** irmao,int indicePai){
	int i;
	(*atual)->keys[(*atual)->quantidadeKeys] = (*pai)->keys[indicePai];
	(*atual)->filhos[(*atual)->quantidadeFilhos] = (*irmao)->filhos[0];
	(*atual)->quantidadeKeys++;
	(*atual)->quantidadeFilhos++;
	(*pai)->keys[indicePai] = (*irmao)->keys[0];
	for(i = 0; i < (*irmao)->quantidadeKeys; i++){
		(*irmao)->keys[i] = (*irmao)->keys[i+1];
		(*irmao)->filhos[i] = (*irmao)->filhos[i+1];
	}
	(*irmao)->keys[i-1] = NULL;
	(*irmao)->filhos[i-1] = NULL;
	(*irmao)->quantidadeKeys--;
	(*irmao)->quantidadeFilhos--;
}

nodo_t* emprestadoEsquerdaInterna(nodo_t** pai, nodo_t** atual, nodo_t** irmao,int indicePai){
	int i;
	for (i = (*atual)->quantidadeKeys; i >= 0; i--) {
		(*atual)->keys[i] = (*atual)->keys[i+1];
		(*atual)->offsets[i] = (*atual)->offsets[i+1];
	}
	(*irmao)->quantidadeKeys--;
	(*irmao)->quantidadeFilhos--;
	(*atual)->keys[0] = (*pai)->keys[indicePai];
	(*atual)->filhos[0] = (*irmao)->filhos[(*irmao)->quantidadeFilhos];
	(*pai)->keys[indicePai] = (*irmao)->keys[(*irmao)->quantidadeKeys];	
}

nodo_t* verificaInterno(nodo_t *atual, int indicePai, int ordem){
	nodo_t *pai = atual->pai,*irmao;
	int i, qtdMinima = (ordem-1)/2;
	
	if(atual->pai->quantidadeFilhos > indicePai){//EXISTE UM IRMAO A DIREITA? POSSO PEGAR EMPRESTA DESSE IRMAO?
	  irmao = atual->pai->filhos[indicePai];
	  if(irmao->quantidadeKeys > qtdMinima){
		return emprestadoDireitaInterna(&pai,&atual,&irmao,indicePai);
	  }
	}else if(indicePai){//EXISTE IRMAO A ESQUERDA? POSSO PEGAR EMPRESTA DESSE IRMAO?
	  	irmao = atual->pai->filhos[indicePai-2];
	  if(irmao->quantidadeKeys > qtdMinima){
		return emprestadoEsquerdaInterna(&pai,&atual,&irmao,indicePai);
	  }
	}
}

nodo_t *removeElemento(nodo_t* atual, int indice, int ordem){
	int i;
	if (!atual)//CASO O NODO COM O ITEM ATUAL SEJA NULO RETORNA
		return NULL;
	
	if(atual->folha){
		indice++;
		while(indice < atual->quantidadeKeys){
			atual->keys[indice-1] = atual->keys[indice];
			atual->offsets[indice-1] = atual->offsets[indice];
			indice++;
		}
		atual->keys[indice] = NULL;
		mataOffsets(atual->offsets[indice]);
		atual->quantidadeKeys--;
		if(!atual->pai)//A REMOCAO FOI NA RAIZ
			return (verificaRaiz(atual));
		
		if(atual->quantidadeKeys >= (ordem-1)/2)//AINDA RESTAM O MINIMO DE ELEMENTOS
			return atual;

		//NAO TERM A QUANTIDADE DE ELEMTNTOS MINIMO
		//ENCONTRA O INDICE NO PAI PARA CONFERIR SE É POSSIVEL PEGAR EMPRESTADO DO IRMAO A ESQUERDA
		for(i = 0; i <= atual->pai->quantidadeFilhos; i++){
			if(atual->pai->filhos[i] == atual){
				break;
			}
		}
		
		verificaFolha(atual, i+1, ordem);
		
	}else{//NAO FOLHA
		indice++;
		while(indice <= atual->quantidadeKeys){
			atual->keys[indice-1] = atual->keys[indice];
			atual->filhos[indice-1] = atual->filhos[indice];
			indice++;
		}
		atual->keys[indice-1] = NULL;
		atual->filhos[indice-1] = NULL;
		atual->quantidadeKeys--;
		atual->quantidadeFilhos--;
		
		if(!atual->pai)//A REMOCAO FOI NA RAIZ
			return (verificaRaiz(atual));
		
		if(atual->quantidadeKeys >= (ordem-1)/2)//AINDA RESTAM O MINIMO DE ELEMENTOS
			return atual;
	}
}
